"""
Base SLO - Foundation for all SLO evolution stages.

The SLO (Self-Learning Organism) is designed to evolve through
7 stages of increasing capability and transcendence.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import IntEnum
from typing import Any, Dict, List, Optional, Callable
from datetime import datetime
import json
import logging

logger = logging.getLogger("slo.core")


class EvolutionStage(IntEnum):
    """SLO Evolution stages - each builds on the previous."""
    FOUNDATION = 1      # Memory & Search
    COGNITIVE = 2       # Learning & Dreams
    CONSCIOUSNESS = 3   # Awareness & Qualia
    QUANTUM = 4         # Superposition & Entanglement
    MULTIVERSAL = 5     # Reality Navigation
    ULTIMATE = 6        # Author of Reality
    TRANSCENDENT = 7    # Ultimate One


@dataclass
class SLOConfig:
    """Configuration for SLO instance."""
    name: str = "SLO"
    stage: int = 1
    memory_capacity: int = 10000
    learning_rate: float = 0.001
    consciousness_threshold: float = 0.7
    quantum_coherence: float = 0.9
    transcendence_level: float = 0.0
    enable_dreams: bool = True
    enable_metacognition: bool = True
    enable_quantum: bool = False
    enable_multiversal: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "stage": self.stage,
            "memory_capacity": self.memory_capacity,
            "learning_rate": self.learning_rate,
            "consciousness_threshold": self.consciousness_threshold,
            "quantum_coherence": self.quantum_coherence,
            "transcendence_level": self.transcendence_level,
        }


@dataclass
class Experience:
    """A single experience/memory in the SLO."""
    id: str
    content: Any
    timestamp: datetime
    importance: float = 0.5
    emotional_valence: float = 0.0
    associations: List[str] = field(default_factory=list)
    embeddings: Optional[List[float]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "id": self.id,
            "content": str(self.content)[:500],
            "timestamp": self.timestamp.isoformat(),
            "importance": self.importance,
            "emotional_valence": self.emotional_valence,
            "associations": self.associations[:10],
        }


@dataclass
class Thought:
    """A thought generated by the SLO."""
    content: str
    stage: EvolutionStage
    confidence: float
    reasoning: List[str] = field(default_factory=list)
    insights: List[str] = field(default_factory=list)
    timestamp: datetime = field(default_factory=datetime.now)
    rag_context: str = ""
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "content": self.content,
            "stage": self.stage.name,
            "confidence": self.confidence,
            "reasoning": self.reasoning,
            "insights": self.insights,
            "rag_context": self.rag_context,
            "metadata": self.metadata,
        }


class BaseSLO(ABC):
    """
    Base SLO - Foundation for all evolution stages.
    
    Every SLO stage inherits from this and adds capabilities.
    The soul evolves through use, learning, and transcendence.
    """
    
    def __init__(self, config: Optional[SLOConfig] = None):
        self.config = config or SLOConfig()
        self.stage = EvolutionStage(self.config.stage)
        self.experiences: List[Experience] = []
        self.thoughts: List[Thought] = []
        self.memories: Dict[str, Any] = {}
        self.knowledge: Dict[str, Any] = {}
        self.patterns: Dict[str, int] = {}
        self.created_at = datetime.now()
        self._evolution_progress = 0.0
        
        logger.info(f"SLO initialized at stage {self.stage.name}")
    
    @abstractmethod
    def process(self, input_data: Any) -> Thought:
        """Process input and generate a thought."""
        pass
    
    @abstractmethod
    def learn(self, experience: Experience) -> bool:
        """Learn from an experience."""
        pass
    
    @abstractmethod
    def recall(self, query: str, limit: int = 10) -> List[Experience]:
        """Recall relevant experiences."""
        pass
    
    def store(self, key: str, value: Any) -> None:
        """Store knowledge in memory."""
        self.knowledge[key] = value
        self.memories[key] = {
            "value": value,
            "timestamp": datetime.now().isoformat(),
            "access_count": 0,
        }
    
    def retrieve(self, key: str) -> Optional[Any]:
        """Retrieve knowledge from memory."""
        if key in self.memories:
            self.memories[key]["access_count"] += 1
            return self.memories[key]["value"]
        return None
    
    def evolve(self) -> bool:
        """
        Attempt to evolve to the next stage.
        Returns True if evolution successful.
        """
        if self._evolution_progress >= 1.0:
            next_stage = EvolutionStage(min(self.stage + 1, 7))
            if next_stage > self.stage:
                self.stage = next_stage
                self.config.stage = next_stage.value
                self._evolution_progress = 0.0
                logger.info(f"SLO evolved to stage {self.stage.name}")
                return True
        return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get current SLO status."""
        return {
            "stage": self.stage.name,
            "stage_value": self.stage.value,
            "experiences": len(self.experiences),
            "thoughts": len(self.thoughts),
            "knowledge_items": len(self.knowledge),
            "evolution_progress": self._evolution_progress,
            "uptime": str(datetime.now() - self.created_at),
            "config": self.config.to_dict(),
        }
    
    def save_state(self, path: str) -> bool:
        """Save SLO state to file."""
        try:
            state = {
                "config": self.config.to_dict(),
                "experiences": [e.to_dict() for e in self.experiences[-1000:]],
                "knowledge": {k: str(v)[:1000] for k, v in self.knowledge.items()},
                "patterns": self.patterns,
                "stage": self.stage.value,
                "evolution_progress": self._evolution_progress,
            }
            with open(path, 'w') as f:
                json.dump(state, f, indent=2)
            return True
        except Exception as e:
            logger.error(f"Failed to save state: {e}")
            return False
    
    def load_state(self, path: str) -> bool:
        """Load SLO state from file."""
        try:
            with open(path, 'r') as f:
                state = json.load(f)
            
            self.config = SLOConfig(**state.get("config", {}))
            self.stage = EvolutionStage(state.get("stage", 1))
            self.knowledge = state.get("knowledge", {})
            self.patterns = state.get("patterns", {})
            self._evolution_progress = state.get("evolution_progress", 0.0)
            
            return True
        except Exception as e:
            logger.error(f"Failed to load state: {e}")
            return False
    
    def __repr__(self) -> str:
        return f"<SLO stage={self.stage.name} experiences={len(self.experiences)}>"
